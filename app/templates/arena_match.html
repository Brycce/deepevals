{% extends "base.html" %}

{% block title %}Arena Match - DeepEvals{% endblock %}

{% block content %}
<div class="arena-page">
    <div class="arena-top-bar">
        <span class="toolbar-info" id="match-info">Loading...</span>
    </div>

    <!-- Generating State -->
    <div id="generating-state" class="arena-generating hidden">
        <div class="generating-box">
            <div class="spinner"></div>
            <h3>Generating outputs...</h3>
            <p>Two models are generating their responses.</p>
            <div id="generation-status" class="generation-status"></div>
        </div>
    </div>

    <!-- Voting State -->
    <div id="voting-state" class="hidden">
        <div class="arena-sticky-header">
            <div class="sticky-panel-header left">
                <span class="panel-label">A</span>
                <span class="panel-title">Option A</span>
                <button class="vote-btn vote-a" data-winner="a">A is better</button>
            </div>
            <div class="sticky-center">
                <button id="sync-toggle" class="toolbar-btn active" title="Toggle sync scroll">
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M4 12h16M4 12l4-4M4 12l4 4M20 12l-4-4M20 12l-4 4"/>
                    </svg>
                    <span>Synced</span>
                </button>
                <button class="vote-btn vote-tie" data-winner="tie">Tie</button>
            </div>
            <div class="sticky-panel-header right">
                <button class="vote-btn vote-b" data-winner="b">B is better</button>
                <span class="panel-title">Option B</span>
                <span class="panel-label">B</span>
            </div>
        </div>

        <div class="arena-panels">
            <div class="arena-panel">
                <div class="panel-content markdown-body" id="output-a">
                    Loading...
                </div>
            </div>

            <div class="arena-panel">
                <div class="panel-content markdown-body" id="output-b">
                    Loading...
                </div>
            </div>
        </div>
    </div>

    <!-- Reveal State -->
    <div id="reveal-state" class="hidden">
        <div class="arena-sticky-header reveal">
            <div class="sticky-panel-header left" id="panel-a-reveal">
                <span class="panel-label">A</span>
                <span class="panel-title" id="reveal-model-a">Model A</span>
                <span class="elo-badge" id="elo-change-a"></span>
            </div>
            <div class="sticky-center">
                <div class="result-badge" id="result-banner">
                    <span id="reveal-result"></span>
                </div>
                <div class="reveal-actions">
                    <button class="vote-btn vote-new" id="new-match-btn" onclick="createNewMatch()">New Match</button>
                    <a href="/arena" class="vote-btn vote-back">Leaderboard</a>
                </div>
            </div>
            <div class="sticky-panel-header right" id="panel-b-reveal">
                <span class="elo-badge" id="elo-change-b"></span>
                <span class="panel-title" id="reveal-model-b">Model B</span>
                <span class="panel-label">B</span>
            </div>
        </div>

        <div class="arena-panels">
            <div class="arena-panel" id="panel-a-content">
                <div class="panel-content markdown-body" id="reveal-output-a">
                </div>
            </div>

            <div class="arena-panel" id="panel-b-content">
                <div class="panel-content markdown-body" id="reveal-output-b">
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
const matchId = '{{ match_id }}';
let voteResult = null;
let syncScroll = true;
let isScrolling = false;
let currentMatchData = null; // Store match data for creating new matches

function renderMarkdown(text) {
    if (!text) return '';
    return marked.parse(text);
}

// Sync scroll functionality
function setupSyncScroll() {
    const panels = document.querySelectorAll('.panel-content');
    if (panels.length < 2) return;

    panels.forEach((panel, index) => {
        panel.addEventListener('scroll', (e) => {
            if (!syncScroll || isScrolling) return;
            isScrolling = true;

            const scrollPercent = panel.scrollTop / (panel.scrollHeight - panel.clientHeight);

            panels.forEach((otherPanel, otherIndex) => {
                if (otherIndex !== index) {
                    const targetScroll = scrollPercent * (otherPanel.scrollHeight - otherPanel.clientHeight);
                    otherPanel.scrollTop = targetScroll;
                }
            });

            requestAnimationFrame(() => { isScrolling = false; });
        });
    });
}

// Toggle sync scroll
document.getElementById('sync-toggle').addEventListener('click', function() {
    syncScroll = !syncScroll;
    this.classList.toggle('active', syncScroll);
    this.querySelector('span').textContent = syncScroll ? 'Synced' : 'Independent';
});

async function loadMatch() {
    try {
        const response = await fetch(`/api/arena/match/${matchId}`);
        if (!response.ok) {
            throw new Error('Match not found');
        }
        const match = await response.json();
        return match;
    } catch (e) {
        console.error('Error loading match:', e);
        return null;
    }
}

async function loadFullMatchData() {
    // Load the full match data including profile_data from the session endpoint
    try {
        const response = await fetch(`/api/arena/match/${matchId}/full`);
        if (response.ok) {
            currentMatchData = await response.json();
        }
    } catch (e) {
        console.error('Error loading full match data:', e);
    }
}

async function createNewMatch() {
    if (!currentMatchData) {
        window.location.href = '/arena';
        return;
    }

    const btn = document.getElementById('new-match-btn');
    btn.disabled = true;
    btn.textContent = 'Creating...';

    try {
        const response = await fetch('/api/arena/match', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({
                profile_data: currentMatchData.profile_data,
                chunk_type: currentMatchData.chunk_type,
            })
        });

        if (!response.ok) {
            throw new Error('Failed to create match');
        }

        const newMatch = await response.json();
        window.location.href = `/arena/match/${newMatch.id}`;
    } catch (e) {
        alert('Error: ' + e.message);
        btn.disabled = false;
        btn.textContent = 'New Match';
    }
}

async function pollForReady() {
    document.getElementById('generating-state').classList.remove('hidden');

    while (true) {
        const response = await fetch(`/api/arena/match/${matchId}/status`);
        const status = await response.json();

        const statusEl = document.getElementById('generation-status');
        statusEl.innerHTML = `
            <div class="gen-item ${status.has_output_a ? 'ready' : ''}">
                <span class="gen-label">A</span>
                <span class="gen-status">${status.has_output_a ? 'Ready' : 'Generating...'}</span>
            </div>
            <div class="gen-item ${status.has_output_b ? 'ready' : ''}">
                <span class="gen-label">B</span>
                <span class="gen-status">${status.has_output_b ? 'Ready' : 'Generating...'}</span>
            </div>
        `;

        if (status.status === 'ready' || status.status === 'completed') {
            break;
        }

        await new Promise(r => setTimeout(r, 2000));
    }

    document.getElementById('generating-state').classList.add('hidden');
    showVotingState();
}

async function showVotingState() {
    const match = await loadMatch();
    if (!match) return;

    if (match.status === 'completed') {
        showRevealState();
        return;
    }

    document.getElementById('match-info').textContent =
        `${match.profile_name} / ${match.chunk_type}`;

    document.getElementById('output-a').innerHTML = renderMarkdown(match.output_a);
    document.getElementById('output-b').innerHTML = renderMarkdown(match.output_b);

    document.getElementById('voting-state').classList.remove('hidden');
    setupSyncScroll();

    document.querySelectorAll('.vote-btn').forEach(btn => {
        if (btn.dataset.winner) {
            btn.addEventListener('click', async () => {
                await submitVote(btn.dataset.winner);
            });
        }
    });
}

async function submitVote(winner) {
    document.querySelectorAll('.vote-btn').forEach(btn => {
        btn.disabled = true;
        btn.style.opacity = '0.5';
    });

    try {
        const response = await fetch(`/api/arena/match/${matchId}/vote`, {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({ winner })
        });

        if (!response.ok) {
            const error = await response.json();
            throw new Error(error.detail || 'Failed to submit vote');
        }

        voteResult = await response.json();
        showRevealState();

    } catch (e) {
        alert('Error: ' + e.message);
        document.querySelectorAll('.vote-btn').forEach(btn => {
            btn.disabled = false;
            btn.style.opacity = '1';
        });
    }
}

async function showRevealState() {
    document.getElementById('voting-state').classList.add('hidden');

    const response = await fetch(`/api/arena/match/${matchId}/reveal`);
    if (!response.ok) {
        alert('Error loading results');
        return;
    }

    const revealed = await response.json();

    document.getElementById('match-info').textContent =
        `${revealed.profile_name} / ${revealed.chunk_type}`;

    // Show winner badge
    const resultEl = document.getElementById('reveal-result');
    const banner = document.getElementById('result-banner');
    if (revealed.winner === 'a') {
        resultEl.textContent = `A wins`;
        banner.className = 'result-badge winner-a';
        document.getElementById('panel-a-content').classList.add('winner');
    } else if (revealed.winner === 'b') {
        resultEl.textContent = `B wins`;
        banner.className = 'result-badge winner-b';
        document.getElementById('panel-b-content').classList.add('winner');
    } else {
        resultEl.textContent = 'Tie';
        banner.className = 'result-badge tie';
    }

    document.getElementById('reveal-model-a').textContent = revealed.model_a_display_name;
    document.getElementById('reveal-model-b').textContent = revealed.model_b_display_name;

    if (voteResult) {
        const changeA = voteResult.model_a.change;
        const changeB = voteResult.model_b.change;
        document.getElementById('elo-change-a').innerHTML =
            `<span class="${changeA >= 0 ? 'positive' : 'negative'}">${changeA >= 0 ? '+' : ''}${changeA}</span>`;
        document.getElementById('elo-change-b').innerHTML =
            `<span class="${changeB >= 0 ? 'positive' : 'negative'}">${changeB >= 0 ? '+' : ''}${changeB}</span>`;
    }

    document.getElementById('reveal-output-a').innerHTML = renderMarkdown(revealed.output_a);
    document.getElementById('reveal-output-b').innerHTML = renderMarkdown(revealed.output_b);

    document.getElementById('reveal-state').classList.remove('hidden');
    setupSyncScroll();

    // Load full match data for creating new matches
    loadFullMatchData();
}

async function init() {
    const match = await loadMatch();
    if (!match) {
        document.getElementById('match-info').textContent = 'Match not found';
        return;
    }

    // Load full match data early for new match button
    loadFullMatchData();

    if (match.status === 'completed') {
        showRevealState();
    } else if (match.status === 'ready') {
        showVotingState();
    } else {
        pollForReady();
    }
}

const script = document.createElement('script');
script.src = 'https://cdn.jsdelivr.net/npm/marked/marked.min.js';
script.onload = init;
document.head.appendChild(script);
{% endblock %}
